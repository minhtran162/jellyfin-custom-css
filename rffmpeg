import asyncio
import websockets
import json
import requests
import click
import logging
import os
import signal
import sys
import shlex
import yaml
import re
from pathlib import Path
from contextlib import contextmanager
from grp import getgrnam
from pwd import getpwnam
from sqlite3 import connect as sqlite_connect
from subprocess import run, PIPE, DEVNULL
from time import sleep
from datetime import datetime
import threading

# Set up the logger
log = logging.getLogger("rffmpeg")

# Use Postgresql if specified, otherwise use SQLite
DB_TYPE = "SQLITE"
SQL_VAR_SIGN = "?"
SQL_PRIMARY_KEY = "INTEGER"
SQL_DATE_TIME = "DATETIME"
POSTGRES_DB = os.environ.get("RFFMPEG_POSTGRES_DB", "rffmpeg")
POSTGRES_USER = os.environ.get("RFFMPEG_POSTGRES_USER")
POSTGRES_PASS = os.environ.get("RFFMPEG_POSTGRES_PASS", "")
POSTGRES_PORT = os.environ.get("RFFMPEG_POSTGRES_PORT", "5432")
POSTGRES_HOST = os.environ.get("RFFMPEG_POSTGRES_HOST", "localhost")

if POSTGRES_USER is not None:
    DB_TYPE = "POSTGRES"
    SQL_VAR_SIGN = "%s"
    SQL_PRIMARY_KEY = "SERIAL"
    SQL_DATE_TIME = "TIMESTAMP"
    POSTGRES_CREDENTIALS = {
        "dbname": POSTGRES_DB,
        "user": POSTGRES_USER,
        "password": POSTGRES_PASS,
        "port": int(POSTGRES_PORT),
        "host": POSTGRES_HOST,
    }
    from psycopg2 import connect as postgres_connect
    from psycopg2 import DatabaseError as postgres_error

# Open a database connection (context manager)
@contextmanager
def dbconn(config, init=False):
    if DB_TYPE == "SQLITE":
        if not init and not Path(config["db_path"]).is_file():
            fail(f"Failed to find database '{config['db_path']}' - did you forget to run 'rffmpeg init' or add all env vars for Postgresql?")
        log.debug("Using SQLite as database.")
        conn = sqlite_connect(config["db_path"])
        conn.execute("PRAGMA foreign_keys = 1")
        cur = conn.cursor()
        yield cur
        conn.commit()
        conn.close()
        log.debug("SQLite connection closed.")
    elif DB_TYPE == "POSTGRES":
        conn = None
        try:
            log.debug("Using Postgresql as database. Connecting...")
            conn = postgres_connect(**POSTGRES_CREDENTIALS)
            cur = conn.cursor()
            cur.execute("SELECT version()")
            db_version = cur.fetchone()
            log.debug(f"Connected to Postgresql version {db_version}")
            yield cur
            conn.commit()
        except (Exception, postgres_error) as error:
            print(error)
            log.error(error)
        finally:
            if conn is not None:
                conn.close()
                log.debug("Postgresql connection closed.")

def fail(msg):
    log.error(msg)
    exit(1)

def load_config():
    default_config_file = "/etc/rffmpeg/rffmpeg.yml"
    config_file = os.environ.get("RFFMPEG_CONFIG", default_config_file)

    if not Path(config_file).is_file():
        log.info(f"No config found in {config_file}. Using default settings.")
        o_config = {
            "rffmpeg": {"logging": {}, "directories": {}, "remote": {}, "commands": {}}
        }
    else:
        with open(config_file, "r") as cfgfh:
            try:
                o_config = yaml.load(cfgfh, Loader=yaml.SafeLoader)
            except Exception as e:
                fail(f"Failed to parse configuration file: {e}")

    config = dict()
    config_base = o_config.get("rffmpeg", dict())
    if not config_base:
        fail("Failed to parse configuration file top level key 'rffmpeg'.")

    config_logging = config_base.get("logging", dict()) or dict()
    config_directories = config_base.get("directories", dict()) or dict()
    config_remote = config_base.get("remote", dict()) or dict()
    config_commands = config_base.get("commands", dict()) or dict()

    config["log_to_file"] = config_logging.get("log_to_file", True)
    config["logfile"] = config_logging.get("logfile", "/var/log/jellyfin/rffmpeg.log")
    config["datedlogfiles"] = config_logging.get("datedlogfiles", False)
    if config["datedlogfiles"]:
        config["datedlogdir"] = config_logging.get("datedlogdir", "/var/log/jellyfin")
        config["logfile"] = config["datedlogdir"] + "/" + datetime.today().strftime("%Y%m%d") + "_rffmpeg.log"
    config["logdebug"] = config_logging.get("debug", False)

    config["state_dir"] = config_directories.get("state", "/var/lib/rffmpeg")
    config["persist_dir"] = config_directories.get("persist", "/run/shm")
    config["dir_owner"] = config_directories.get("owner", "jellyfin")
    config["dir_group"] = config_directories.get("group", "sudo")

    config["remote_user"] = config_remote.get("user", "")
    config["remote_args"] = config_remote.get("args", ["-i", "/var/lib/jellyfin/.ssh/id_rsa"]) or []
    config["persist_time"] = config_remote.get("persist", 300)

    config["ssh_command"] = config_commands.get("ssh", "/usr/bin/ssh")
    config["pre_commands"] = config_commands.get("pre", []) or []
    config["ffmpeg_command"] = config_commands.get("ffmpeg", "/usr/lib/jellyfin-ffmpeg/ffmpeg")
    config["ffprobe_command"] = config_commands.get("ffprobe", "/usr/lib/jellyfin-ffmpeg/ffprobe")
    config["fallback_ffmpeg_command"] = config_commands.get("fallback_ffmpeg", "/usr/lib/jellyfin-ffmpeg/ffmpeg")
    config["fallback_ffprobe_command"] = config_commands.get("fallback_ffprobe", "/usr/lib/jellyfin-ffmpeg/ffprobe")

    config["db_path"] = config["state_dir"] + "/rffmpeg.db"
    config["special_flags"] = ["-version", "-encoders", "-decoders", "-hwaccels", "-filters", "-h", "-muxers", "-fp_format"] + config_commands.get("special_flags", [])
    config["current_pid"] = os.getpid()

    return config

def cleanup(signum="", frame=""):
    global config
    log.debug(f"Cleaning up after signal {signum} PID {config['current_pid']}")

    remote_processes_to_kill = []
    try:
        with dbconn(config) as cur:
            cur.execute(
                f"SELECT hosts.hostname, processes.cmd FROM processes JOIN hosts ON processes.host_id = hosts.id WHERE processes.process_id = {SQL_VAR_SIGN} AND hosts.hostname != 'localhost'",
                (config["current_pid"],),
            )
            remote_processes = cur.fetchall()
            for hostname, cmd in remote_processes:
                if hostname and hostname not in ["localhost", "127.0.0.1"]:
                    remote_processes_to_kill.append((hostname, cmd))
            cur.execute(f"DELETE FROM states WHERE process_id = {SQL_VAR_SIGN}", (config["current_pid"],))
            cur.execute(f"DELETE FROM processes WHERE process_id = {SQL_VAR_SIGN}", (config["current_pid"],))
    except Exception as e:
        log.error(f"Error during database cleanup: {str(e)}")

    for hostname, cmd in remote_processes_to_kill:
        try:
            log.debug(f"Attempting to terminate remote process on {hostname} for command: {cmd}")
            ssh_base = generate_ssh_command(config, hostname, interactive=False)
            cmd_pattern = "grep '[f]mpeg'" if not (output_matches := re.findall(r'(/\S+\.\w+)', cmd)) else f"grep '{os.path.basename(next((m for m in output_matches if not m.endswith('.log')), ''))}'"
            kill_cmd = ssh_base + ["bash", "-c", f"ps aux | {cmd_pattern} | awk '{{print $2}}' | xargs -r kill -TERM"]
            log.debug(f"Running targeted graceful kill command on {hostname}")
            run_command(kill_cmd, DEVNULL, PIPE, PIPE)
            sleep(0.5)
            force_kill_cmd = ssh_base + ["bash", "-c", f"ps aux | {cmd_pattern} | awk '{{print $2}}' | xargs -r kill -9"]
            log.debug(f"Running targeted forceful kill command on {hostname}")
            run_command(force_kill_cmd, DEVNULL, PIPE, PIPE)
            fallback_kill_cmd = ssh_base + ["bash", "-c", "pkill -9 ffmpeg || true"]
            log.debug(f"Running fallback kill command on {hostname}")
            run_command(fallback_kill_cmd, DEVNULL, DEVNULL, DEVNULL)
            log.debug(f"Sent termination signals to remote processes on {hostname}")
        except Exception as e:
            log.error(f"Failed to terminate remote process on {hostname}: {str(e)}")

def generate_ssh_command(config, target_hostname, interactive=True):
    ssh_command = [config["ssh_command"], "-q"]
    if interactive:
        ssh_command.append("-t")
    ssh_command.extend(["-o", "ConnectTimeout=1", "-o", "ConnectionAttempts=1", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"])
    if config["persist_time"] > 0:
        ssh_command.extend(["-o", "ControlMaster=auto", "-o", f"ControlPath={config['persist_dir']}/ssh-%r@%h:%p", "-o", f"ControlPersist={config['persist_time']}"])
    ssh_command.extend(arg for arg in config["remote_args"] if arg)
    ssh_command.append(f"{config['remote_user']}@{target_hostname}")
    return ssh_command

def run_command(command, stdin, stdout, stderr):
    p = run(command, shell=False, bufsize=0, universal_newlines=True, stdin=stdin, stdout=stdout, stderr=stderr)
    return p

def get_target_host(config):
    log.debug("Determining optimal target host")
    with dbconn(config) as cur:
        cur.execute("SELECT * FROM hosts")
        hosts = cur.fetchall()
        cur.execute("SELECT * FROM processes")
        processes = cur.fetchall()

    host_mappings = {}
    for host in hosts:
        hid, servername, hostname, weight, created = host
        with dbconn(config) as cur:
            cur.execute(f"SELECT * FROM states WHERE host_id = {SQL_VAR_SIGN} ORDER BY id DESC", (hid,))
            current_state = cur.fetchone()
        host_mappings[hid] = {
            "hostname": hostname,
            "weight": weight,
            "servername": servername,
            "current_state": current_state[3] if current_state else "idle",
            "marking_pid": current_state[2] if current_state else "N/A",
            "commands": [proc[2] for proc in processes if proc[1] == hid],
        }

    lowest_count = 9999
    target_hid = target_hostname = target_servername = None
    for hid, host in host_mappings.items():
        log.debug(f"Trying host ID {hid} '{host['hostname']}'")
        if host["current_state"] == "bad":
            log.debug(f"Host previously marked bad by PID {host['marking_pid']}")
            continue
        if host["hostname"] not in ["localhost", "127.0.0.1"]:
            log.debug("Running SSH test")
            test_ssh_command = generate_ssh_command(config, host["hostname"], interactive=False)
            test_ssh_command.remove("-q")
            test_ssh_command = [arg.replace('@', '', 1) if arg.startswith('@') else arg for arg in test_ssh_command]
            test_ffmpeg_command = [config["ffmpeg_command"], "-version"]
            ret = run_command(test_ssh_command + test_ffmpeg_command, PIPE, PIPE, PIPE)
            if ret.returncode != 0:
                log.warning(f"Marking host {host['hostname']} ({host['servername']}) as bad due to retcode {ret.returncode}")
                with dbconn(config) as cur:
                    cur.execute(f"INSERT INTO states (host_id, process_id, state) VALUES ({SQL_VAR_SIGN}, {SQL_VAR_SIGN}, {SQL_VAR_SIGN})", (hid, config["current_pid"], "bad"))
                continue
            log.debug(f"SSH test succeeded with retcode {ret.returncode}")
        if host["current_state"] == "idle":
            target_hid, target_hostname, target_servername = hid, host["hostname"], host["servername"]
            log.debug("Selecting host as idle")
            break
        weighted_proc_count = len(host["commands"]) // host["weight"]
        if weighted_proc_count < lowest_count:
            lowest_count, target_hid, target_hostname, target_servername = weighted_proc_count, hid, host["hostname"], host["servername"]
            log.debug(f"Selecting host as current lowest proc count (raw count: {len(host['commands'])}, weighted count: {weighted_proc_count})")
    log.debug(f"Found optimal host ID {target_hid} '{target_hostname}' ({target_servername})")
    return target_hid, target_hostname, target_servername

def run_local_command(config, target_hid, command, command_args, stderr_as_stdout=False, mapped_cmd=None):
    rffmpeg_command = [mapped_cmd or command]
    local_stdin = sys.stdin
    for i in range(len(command_args)):
        if command_args[i] == "-i" and (i + 1) < len(command_args):
            input_param = command_args[i+1]
            actual_file = input_param[len("file:"):].strip('"\'') if input_param.startswith("file:") else input_param
            if os.path.isfile(actual_file):
                command_args[i+1] = "-"
                local_stdin = open(actual_file, "rb")
                break
    stdin, stderr = local_stdin, sys.stderr
    stdout = sys.stderr if stderr_as_stdout else sys.stdout
    rffmpeg_command.extend(command_args)
    log.info("Running command on host 'localhost'")
    log.debug(f"Local command: {' '.join(rffmpeg_command)}")
    target_hid = target_hid if target_hid is not None else 0
    with dbconn(config) as cur:
        cur.execute(f"INSERT INTO processes (host_id, process_id, cmd) VALUES ({SQL_VAR_SIGN}, {SQL_VAR_SIGN}, {SQL_VAR_SIGN})", (target_hid, config["current_pid"], command + ' ' + ' '.join(command_args)))
        cur.execute(f"INSERT INTO states (host_id, process_id, state) VALUES ({SQL_VAR_SIGN}, {SQL_VAR_SIGN}, {SQL_VAR_SIGN})", (target_hid, config["current_pid"], "active"))
    return run_command(rffmpeg_command, stdin, stdout, stderr)

def run_local_ffmpeg(config, target_hid, ffmpeg_args):
    if "ffprobe" in cmd_name:
        return run_local_command(config, target_hid, cmd_name, ffmpeg_args, mapped_cmd=config["fallback_ffprobe_command"])
    return run_local_command(config, target_hid, cmd_name, ffmpeg_args, stderr_as_stdout=not any(item in config["special_flags"] for item in ffmpeg_args), mapped_cmd=config["fallback_ffmpeg_command"])

def run_remote_command(config, target_hid, target_hostname, target_servername, command, command_args, stderr_as_stdout=False, mapped_cmd=None, pre_commands=[]):
    rffmpeg_ssh_command = generate_ssh_command(config, target_hostname, interactive=True)
    rffmpeg_ssh_command = [arg.replace('@', '', 1) if arg.startswith('@') else arg for arg in rffmpeg_ssh_command]
    rffmpeg_command = [cmd for cmd in pre_commands if cmd] + [mapped_cmd or command]
    local_stdin = sys.stdin
    for i in range(len(command_args)):
        if command_args[i] == "-i" and (i + 1) < len(command_args):
            input_param = command_args[i+1]
            actual_file = input_param[len("file:"):].strip("\"'") if input_param.startswith("file:") else input_param
            if os.path.isfile(actual_file):
                command_args[i+1] = "-"
                local_stdin = open(actual_file, "rb")
                break
    stdin, stderr = local_stdin, sys.stderr
    stdout = sys.stderr if stderr_as_stdout else sys.stdout
    sub_counter = 0
    for idx, arg in enumerate(command_args):
        if "subtitles=f=" in arg:
            matches = re.finditer(r"subtitles=f=(?:['\"](.*?)['\"]|([^:,\s]+))", arg)
            new_arg = arg
            for m in matches:
                subtitle_file = m.group(1) or m.group(2)
                log.debug(f"Found subtitle file reference: {subtitle_file}")
                if os.path.isfile(subtitle_file):
                    file_extension = os.path.splitext(subtitle_file)[1] or ".srt"
                    temp_remote_path = f"/tmp/ffmpeg_subs_{config['current_pid']}_{sub_counter}{file_extension}"
                    sub_counter += 1
                    log.debug(f"Transferring subtitle file to remote path: {temp_remote_path}")
                    ssh_args = generate_ssh_command(config, target_hostname, interactive=False)
                    with open(subtitle_file, 'rb') as f:
                        subtitle_content = f.read()
                    transfer_cmd = ssh_args + [f"cat > {temp_remote_path}"]
                    log.debug(f"Transfer command: {' '.join(transfer_cmd)}")
                    result = run(transfer_cmd, input=subtitle_content, stderr=PIPE)
                    if result.returncode != 0:
                        log.error(f"Failed to transfer subtitle file: {result.stderr.decode()}")
                    else:
                        log.debug("Subtitle file transfer successful")
                        run(ssh_args + [f"chmod 644 {temp_remote_path}"], stdout=DEVNULL, stderr=DEVNULL)
                        if f"'{subtitle_file}'" in new_arg:
                            new_arg = new_arg.replace(f"'{subtitle_file}'", f"'{temp_remote_path}'")
                        elif f'"{subtitle_file}"' in new_arg:
                            new_arg = new_arg.replace(f'"{subtitle_file}"', f'"{temp_remote_path}"')
                        else:
                            pattern = r'(subtitles=f=)' + re.escape(subtitle_file) + r'([,:)]|$)'
                            new_arg = re.sub(pattern, r'\1' + temp_remote_path + r'\2', new_arg)
            if new_arg != arg:
                command_args[idx] = new_arg
                log.debug(f"Updated filter argument: {new_arg}")
    rffmpeg_command.extend(map(shlex.quote, command_args))
    log.info(f"Running command on host '{target_hostname}' ({target_servername})")
    log.debug(f"Remote command: {' '.join(rffmpeg_ssh_command + rffmpeg_command)}")
    with dbconn(config) as cur:
        cur.execute(f"INSERT INTO processes (host_id, process_id, cmd) VALUES ({SQL_VAR_SIGN}, {SQL_VAR_SIGN}, {SQL_VAR_SIGN})", (target_hid, config["current_pid"], command + ' ' + ' '.join(command_args)))
        cur.execute(f"INSERT INTO states (host_id, process_id, state) VALUES ({SQL_VAR_SIGN}, {SQL_VAR_SIGN}, {SQL_VAR_SIGN})", (target_hid, config["current_pid"], "active"))
    return run_command(rffmpeg_ssh_command + rffmpeg_command, stdin, stdout, stderr)

def run_remote_ffmpeg(config, target_hid, target_hostname, target_servername, ffmpeg_args):
    if "ffprobe" in cmd_name:
        return run_remote_command(config, target_hid, target_hostname, target_servername, cmd_name, ffmpeg_args, mapped_cmd=config["ffprobe_command"], pre_commands=config["pre_commands"])
    return run_remote_command(config, target_hid, target_hostname, target_servername, cmd_name, ffmpeg_args, stderr_as_stdout=not any(item in config["special_flags"] for item in ffmpeg_args), mapped_cmd=config["ffmpeg_command"], pre_commands=config["pre_commands"])

def setup_logging(config):
    logging_level = logging.DEBUG if config["logdebug"] else logging.INFO
    if config["log_to_file"]:
        logging.basicConfig(filename=config["logfile"], level=logging_level, format="%(asctime)s - %(name)s[%(process)s] - %(levelname)s - %(message)s")
    else:
        logging.basicConfig(level=logging_level, format="%(asctime)s - %(name)s[%(process)s] - %(levelname)s - %(message)s")

def hook_signals():
    for sig in (signal.SIGTERM, signal.SIGINT, signal.SIGQUIT, signal.SIGHUP):
        signal.signal(sig, cleanup)

# Thêm các biến cấu hình cho Jellyfin
JELLYFIN_URL = os.environ.get("JELLYFIN_URL", "https://jellyfin.suzushina.duckdns.org")
JELLYFIN_API_KEY = os.environ.get("JELLYFIN_API_KEY", "f284b7794c5a4490a30f1b6b84d02261")

async def jellyfin_websocket(config):
    if not JELLYFIN_API_KEY:
        log.error("JELLYFIN_API_KEY is not set. Cannot connect to Jellyfin WebSocket.")
        return
    uri = f"{JELLYFIN_URL.replace('http', 'ws')}/socket?api_key={JELLYFIN_API_KEY}"
    async with websockets.connect(uri) as websocket:
        log.info("Connected to Jellyfin WebSocket")
        while True:
            message = await websocket.recv()
            data = json.loads(message)
            if data.get("MessageType") == "Playstate" and data.get("Data", {}).get("PlayCommand") == "Stop":
                log.info("Detected stop event from Jellyfin")
                cleanup()

def start_websocket(config):
    asyncio.run(jellyfin_websocket(config))

def run_ffmpeg(config, ffmpeg_args):
    hook_signals()
    setup_logging(config)
    log.info(f"Starting rffmpeg as {cmd_name} with args: {' '.join(ffmpeg_args)}")
    target_hid, target_hostname, target_servername = get_target_host(config)
    websocket_thread = threading.Thread(target=start_websocket, args=(config,))
    websocket_thread.start()
    try:
        returncode = 200
        if not target_hostname or target_hostname == "localhost":
            ret = run_local_ffmpeg(config, None, ffmpeg_args)
            returncode = ret.returncode
        else:
            ret = run_remote_ffmpeg(config, target_hid, target_hostname, target_servername, ffmpeg_args)
            returncode = ret.returncode
    finally:
        if returncode == 0:
            log.info(f"Finished rffmpeg with return code {ret.returncode}")
        else:
            log.error(f"Finished rffmpeg with return code {ret.returncode}")
        exit(returncode)

def run_control(config):
    CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"], max_content_width=120)

    @click.group(context_settings=CONTEXT_SETTINGS)
    def rffmpeg_click():
        if not Path(config["state_dir"]).is_dir() or not Path(config["db_path"]).is_file():
            return
        with dbconn(config) as cur:
            cur.execute("SELECT COUNT(*) AS CNTREC FROM pragma_table_info('hosts') WHERE name='servername'")
            if cur.fetchone()[0] == 0:
                cur.execute("ALTER TABLE hosts ADD servername TEXT NOT NULL DEFAULT 'invalid'")
                did_alter_0001AddServername = True
            else:
                did_alter_0001AddServername = False
        if did_alter_0001AddServername:
            with dbconn(config) as cur:
                cur.execute("SELECT * FROM hosts")
                for host in cur.fetchall():
                    hid, servername, hostname, weight, created = host
                    if servername == "invalid":
                        cur.execute(f"UPDATE hosts SET servername = {SQL_VAR_SIGN} WHERE hostname = {SQL_VAR_SIGN}", (hostname, hostname))

    @click.command(name="init", short_help="Initialize the system.")
    @click.option("--no-root", "no_root_flag", is_flag=True, default=False, help="Bypass root check and permission adjustments.")
    @click.option("-y", "--yes", "confirm_flag", is_flag=True, default=False, help="Confirm initialization.")
    def rffmpeg_click_init(no_root_flag, confirm_flag):
        if not no_root_flag and os.getuid() != 0:
            click.echo("Error: This command requires root privileges.")
            exit(1)
        if not confirm_flag:
            try:
                click.confirm("Are you sure you want to (re)initialize the database", prompt_suffix="? ", abort=True)
            except Exception:
                fail("Aborting due to failed confirmation.")
        click.echo("Initializing database")
        if not Path(config["state_dir"]).is_dir():
            try:
                os.makedirs(config["state_dir"])
            except OSError as e:
                fail(f"Failed to create state directory '{config['state_dir']}': {e}")
        try:
            with dbconn(config, True) as cur:
                cur.execute("DROP TABLE IF EXISTS hosts")
                cur.execute("DROP TABLE IF EXISTS processes")
                cur.execute("DROP TABLE IF EXISTS states")
                cur.execute(f"CREATE TABLE hosts (id {SQL_PRIMARY_KEY} PRIMARY KEY, servername TEXT NOT NULL UNIQUE, hostname TEXT NOT NULL, weight INTEGER DEFAULT 1, created {SQL_DATE_TIME} NOT NULL)")
                cur.execute(f"CREATE TABLE processes (id {SQL_PRIMARY_KEY} PRIMARY KEY, host_id INTEGER, process_id INTEGER, cmd TEXT)")
                cur.execute(f"CREATE TABLE states (id {SQL_PRIMARY_KEY} PRIMARY KEY, host_id INTEGER, process_id INTEGER, state TEXT)")
        except Exception as e:
            fail(f"Failed to create database: {e}")
        if not no_root_flag:
            os.chown(config["state_dir"], getpwnam(config["dir_owner"]).pw_uid, getgrnam(config["dir_group"]).gr_gid)
            os.chmod(config["state_dir"], 0o770)
            if DB_TYPE == "SQLITE":
                os.chown(config["db_path"], getpwnam(config["dir_owner"]).pw_uid, getgrnam(config["dir_group"]).gr_gid)
                os.chmod(config["db_path"], 0o660)

    rffmpeg_click.add_command(rffmpeg_click_init)

    @click.command(name="status", short_help="Show hosts and status.")
    def rffmpeg_click_status():
        with dbconn(config) as cur:
            cur.execute("SELECT * FROM hosts")
            hosts = cur.fetchall()
            cur.execute("SELECT * FROM processes")
            processes = cur.fetchall()
            cur.execute("SELECT * FROM states")
            states = cur.fetchall()
        fallback_processes = [proc for proc in processes if proc[1] == 0]
        host_mappings = {0: {"hostname": "localhost (fallback)", "servername": "localhost (fallback)", "weight": 0, "current_state": "fallback", "commands": fallback_processes}} if fallback_processes else {}
        for host in hosts:
            hid, servername, hostname, weight, created = host
            with dbconn(config) as cur:
                cur.execute(f"SELECT * FROM states WHERE host_id = {SQL_VAR_SIGN} ORDER BY id DESC", (hid,))
                current_state = cur.fetchone()
            host_mappings[hid] = {
                "hostname": hostname,
                "servername": servername,
                "weight": weight,
                "current_state": current_state[3] if current_state else "idle",
                "commands": [proc for proc in processes if proc[1] == hid],
            }
        hostname_length = max(len(host["hostname"]) for host in host_mappings.values()) + 1 if host_mappings else 9
        servername_length = max(len(host["servername"]) for host in host_mappings.values()) + 1 if host_mappings else 11
        hid_length = max(len(str(hid)) for hid in host_mappings) + 1 if host_mappings else 3
        weight_length = max(len(str(host["weight"])) for host in host_mappings.values()) + 1 if host_mappings else 7
        state_length = max(len(host["current_state"]) for host in host_mappings.values()) + 1 if host_mappings else 6
        output = [f"\033[1m{'Hostname': <{hostname_length}} {'Servername': <{servername_length}} {'ID': <{hid_length}} {'Weight': <{weight_length}} {'State': <{state_length}} Active Commands\033[0m"]
        for hid, host in host_mappings.items():
            first_command = f"PID {host['commands'][0][2]}: {host['commands'][0][3]}" if host["commands"] else "N/A"
            host_entry = [f"{host['hostname']: <{hostname_length}} {host['servername']: <{servername_length}} {hid: <{hid_length}} {host['weight']: <{weight_length}} {host['current_state']: <{state_length}} {first_command}"]
            host_entry.extend(f"{'': <{hostname_length}} {'': <{servername_length}} {'': <{hid_length}} {'': <{weight_length}} {'': <{state_length}} PID {command[2]}: {command[3]}" for command in host["commands"][1:])
            output.append("\n".join(host_entry))
        click.echo("\n".join(output))

    rffmpeg_click.add_command(rffmpeg_click_status)

    @click.command(name="add", short_help="Add a host.")
    @click.option("-w", "--weight", "weight", required=False, default=1, help="The weight of the host.")
    @click.option("-n", "--name", "name", required=False, default=None, help="The name of the host (if different from the HOST).")
    @click.argument("host")
    def rffmpeg_click_add(weight, name, host):
        created = datetime.now()
        name = name or host
        click.echo(f"Adding new host '{host}' ({name})")
        with dbconn(config) as cur:
            cur.execute(f"INSERT INTO hosts (servername, hostname, weight, created) VALUES ({SQL_VAR_SIGN}, {SQL_VAR_SIGN}, {SQL_VAR_SIGN}, {SQL_VAR_SIGN})", (name, host, weight, created))

    rffmpeg_click.add_command(rffmpeg_click_add)

    @click.command(name="remove", short_help="Remove a host.")
    @click.argument("host")
    def rffmpeg_click_remove(host):
        try:
            host = int(host)
            field = "id"
        except ValueError:
            field, fieldAlt = "servername", "hostname"
        with dbconn(config) as cur:
            cur.execute(f"SELECT * FROM hosts WHERE {field} = {SQL_VAR_SIGN}", (host,))
            entry = cur.fetchall()
            if not entry:
                cur.execute(f"SELECT * FROM hosts WHERE {fieldAlt} = {SQL_VAR_SIGN}", (host,))
                entry = cur.fetchall()
                if not entry:
                    fail("No hosts found to delete!")
            click.echo(f"Removing {len(entry)} host{'s' if len(entry) > 1 else ''}:")
            for host in entry:
                hid, servername, hostname, weight, created = host
                click.echo(f"\tID: {hid}\tHostname: {hostname}\tServername: {servername}")
                cur.execute(f"DELETE FROM hosts WHERE id = {SQL_VAR_SIGN}", (hid,))

    rffmpeg_click.add_command(rffmpeg_click_remove)

    @click.command(name="run", short_help="Run a command.", context_settings={"ignore_unknown_options": True})
    @click.option("--stderr-as-stdout", "stderr_as_stdout", is_flag=True, default=False, help="Use stderr as stdout for the command.")
    @click.argument('full_command', nargs=-1, type=click.UNPROCESSED)
    def rffmpeg_click_run(stderr_as_stdout, full_command):
        hook_signals()
        setup_logging(config)
        command, command_args = full_command[0], full_command[1:]
        log.info(f"Starting rffmpeg as {command} with args: {' '.join(command_args)}")
        target_hid, target_hostname, target_servername = get_target_host(config)
        ret = run_local_command(config, target_hid, command, command_args) if not target_hostname or target_hostname == "localhost" else run_remote_command(config, target_hid, target_hostname, target_servername, command, command_args, stderr_as_stdout=stderr_as_stdout)
        cleanup()
        if ret.returncode == 0:
            log.info(f"Finished rffmpeg with return code {ret.returncode}")
        else:
            log.error(f"Finished rffmpeg with return code {ret.returncode}")
        exit(ret.returncode)

    rffmpeg_click.add_command(rffmpeg_click_run)

    @click.command(name="log", short_help="View the rffmpeg log.")
    @click.option("-f", "--follow", "follow_flag", is_flag=True, default=False, help="Follow new log entries.")
    def rffmpeg_click_log(follow_flag):
        if follow_flag:
            if not os.path.exists(config["logfile"]):
                click.echo("Failed to find log file; have you initialized rffmpeg?")
                exit(1)
            with open(config["logfile"]) as file_:
                file_.seek(0, 2)
                while True:
                    curr_position = file_.tell()
                    line = file_.readline()
                    if not line:
                        file_.seek(curr_position)
                        sleep(0.1)
                    else:
                        click.echo(line, nl=False)
        else:
            with open(config["logfile"], "r") as logfh:
                click.echo_via_pager(logfh.readlines())

    rffmpeg_click.add_command(rffmpeg_click_log)

    @click.command(name="clear", short_help="Clear processes and states.")
    @click.argument("host", required=False, default=None)
    def rffmpeg_click_clear(host):
        with dbconn(config) as cur:
            if host is not None:
                try:
                    host = int(host)
                    field = "id"
                except ValueError:
                    field, fieldAlt = "servername", "hostname"
                cur.execute(f"SELECT id FROM hosts WHERE {field} = {SQL_VAR_SIGN}", (host,))
                entry = cur.fetchall()
                if not entry:
                    cur.execute(f"SELECT id FROM hosts WHERE {fieldAlt} = {SQL_VAR_SIGN}", (host,))
                    entry = cur.fetchall()
                    if not entry:
                        fail("Host not found!")
                if len(entry) > 1:
                    fail("Multiple hosts found, please be more specific!")
                host_id = entry[0][0]
                click.echo(f"Clearing all active processes and states for host ID '{host_id}'")
                cur.execute(f"SELECT id FROM processes WHERE host_id = {SQL_VAR_SIGN}", (host_id,))
                processes = cur.fetchall()
                cur.execute(f"SELECT id FROM states WHERE host_id = {SQL_VAR_SIGN}", (host_id,))
                states = cur.fetchall()
                for process in processes:
                    cur.execute(f"DELETE FROM processes WHERE id = {SQL_VAR_SIGN}", process)
                for state in states:
                    cur.execute(f"DELETE FROM states WHERE id = {SQL_VAR_SIGN}", state)
            else:
                click.echo("Clearing all active processes and states")
                cur.execute("DELETE FROM processes")
                cur.execute("DELETE FROM states")

    rffmpeg_click.add_command(rffmpeg_click_clear)
    return rffmpeg_click(obj={})

if __name__ == "__main__":
    all_args = sys.argv
    cmd_name = all_args[0]
    config = load_config()
    if "rffmpeg" in cmd_name:
        run_control(config)
    else:
        ffmpeg_args = all_args[1:]
        run_ffmpeg(config, ffmpeg_args)